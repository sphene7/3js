<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js æ‰‹åŠ¿æ§åˆ¶åœ£è¯æ ‘</title>
    <style>
        /* ğŸ¨ å“‘å…‰ç»¿ + é‡‘å±é‡‘ + åœ£è¯çº¢ ä¸»è‰²ç³» */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0A141A; /* æ·±å¤œè“/å¢¨ç»¿èƒŒæ™¯ï¼Œè¡¬æ‰˜è¾‰å…‰ */
            color: #EAECEF;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #info-box {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            z-index: 100;
            border-left: 5px solid #FF4500; /* åœ£è¯çº¢ */
        }

        #info-box h3 {
            margin-top: 0;
            color: #FFD700; /* é‡‘å±é‡‘ */
        }

        #camera-feed {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0; /* æ”¾ç½®åœ¨ Three.js ç”»å¸ƒä¹‹ä¸‹ï¼Œä»…ç”¨äº MediaPipe å¤„ç† */
            visibility: hidden; /* éšè—è§†é¢‘æµï¼Œä½†ä¿æŒæ¿€æ´» */
        }

        /* ğŸ“¸ ç…§ç‰‡ä¸Šä¼ åŒºåŸŸ */
        #photo-upload-container {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #FFD700;
        }
        #photo-upload-container button {
            background-color: #008000; /* å“‘å…‰ç»¿ */
            color: #FFFFFF;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #photo-upload-container button:hover {
            background-color: #006400;
        }
    </style>
</head>
<body>
    <video id="camera-feed" playsinline></video>
    <div id="info-box">
        <h3>âœ¨ 3D åœ£è¯æ ‘æ‰‹åŠ¿æ§åˆ¶</h3>
        <p>å½“å‰çŠ¶æ€: <span id="current-state">åŠ è½½ä¸­...</span></p>
        <ul>
            <li>**æ¡æ‹³ (Fist):** åˆæ‹¢æ€ (åˆå§‹)</li>
            <li>**å¼ å¼€äº”æŒ‡ (Open Hand):** æ•£å¼€æ€ (æ¼‚æµ®)</li>
            <li>**æŠ“å– (Grab):** é€‰ä¸­ç…§ç‰‡æ”¾å¤§</li>
            <li>**æ‰‹éƒ¨æ—‹è½¬/ç§»åŠ¨:** è°ƒæ•´è§†è§’</li>
        </ul>
    </div>
    <div id="photo-upload-container">
        <input type="file" id="photo-input" accept="image/*" multiple style="display: none;">
        <button onclick="document.getElementById('photo-input').click()">ä¸Šä¼ ç…§ç‰‡äº‘</button>
        <span id="photo-count"> (0 å¼ ç…§ç‰‡)</span>
    </div>

    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

    <!-- <script src="https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js"></script> -->
    <!-- <script src="https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js"></script> -->
    <!-- <script src="https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/ShaderPass.js"></script> -->
    <!-- <script src="https://unpkg.com/three@0.160.0/examples/jsm/shaders/CopyShader.js"></script> -->
    <!-- <script src="https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js"></script> -->
    <script src="https://unpkg.com/@tweenjs/tween.js@18.6.4/dist/tween.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.8/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js" crossorigin="anonymous"></script>

    <script type="module">
        
        // å¯¼å…¥ TWEEN.js (å¦‚æœä½¿ç”¨æ¨¡å—åŒ–çš„æ–¹å¼)
        // import * as TWEEN from 'https://unpkg.com/@tweenjs/tween.js@18.6.4/dist/tween.esm.js'; 
        // ç”±äºä½¿ç”¨ UMD å¼•å…¥ï¼Œæ­¤å¤„ TWEEN å¯ç›´æ¥è®¿é—®
        import { EffectComposer } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
        import { ShaderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/ShaderPass.js';
        import { CopyShader } from 'https://unpkg.com/three@0.160.0/examples/jsm/shaders/CopyShader.js';
        import { UnrealBloomPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        // --- å…¨å±€å˜é‡å’Œé…ç½® ---
        const CONFIG = {
            PARTICLE_COUNT: 5000,
            PHOTO_COUNT_MAX: 50,
            BLOOM_STRENGTH: 1.5, // ç”µå½±æ„Ÿè¾‰å…‰å¼ºåº¦
            BLOOM_THRESHOLD: 0,
            BLOOM_RADIUS: 0.5,
            TREE_HEIGHT: 5,
            STATE_TRANSITION_DURATION: 1500, // çŠ¶æ€åˆ‡æ¢åŠ¨ç”»æ—¶é—´ (ms)
            HAND_SENSITIVITY: 0.005, // æ‰‹éƒ¨ç§»åŠ¨å¯¹ç›¸æœºæ—‹è½¬çš„æ•æ„Ÿåº¦
            INITIAL_CAMERA_POS: new THREE.Vector3(0, 2.5, 8),
        };

        const STATE = {
            CLOSED: 'CLOSED', // åˆæ‹¢æ€ (åœ†é”¥ä½“)
            SCATTERED: 'SCATTERED', // æ•£å¼€æ€ (ç©ºé—´æ¼‚æµ®)
            PHOTO_ENLARGED: 'PHOTO_ENLARGED', // ç…§ç‰‡æ”¾å¤§æ€
        };

        let currentState = STATE.CLOSED;
        let renderer, scene, camera, composer;
        let clock = new THREE.Clock();
        let particleMesh, photoPlanes = [];
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let cameraTarget = new THREE.Vector3(0, CONFIG.TREE_HEIGHT / 2, 0); // ç›¸æœºç„¦ç‚¹
        let selectedPhoto = null; // å½“å‰è¢«é€‰ä¸­çš„ç…§ç‰‡
        let originalPhotoPositions = []; // å­˜å‚¨ç…§ç‰‡çš„åŸå§‹/æ•£å¼€ä½ç½®

        // --- 1. Three.js åœºæ™¯åˆå§‹åŒ– ---
        function initScene() {
            // åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0A141A); // å¢¨é»‘èƒŒæ™¯

            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(CONFIG.INITIAL_CAMERA_POS);
            camera.lookAt(cameraTarget);

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.5; // æé«˜æ›å…‰ä»¥é…åˆè¾‰å…‰
            document.body.appendChild(renderer.domElement);

            // å…‰æº - æŸ”å’Œç¯å¢ƒå…‰
            scene.add(new THREE.AmbientLight(0xFFFFFF, 0.2));
            // èšå…‰ç¯ - æ¨¡æ‹Ÿé¡¶ç¯å’Œè¾‰å…‰æº
            const pointLight = new THREE.PointLight(0xFFFFFF, 5, 50, 2);
            pointLight.position.set(0, CONFIG.TREE_HEIGHT * 2, 0);
            scene.add(pointLight);

            // åæœŸå¤„ç†ï¼šè¾‰å…‰ä¸å…‰æ™•æ•ˆæœ (UnrealBloomPass)
            setupPostProcessing();

            // åˆ›å»ºåœ£è¯æ ‘è£…é¥°ç‰© (ç²’å­/å®ä¾‹åŒ–å‡ ä½•ä½“)
            createChristmasParticles();

            window.addEventListener('resize', onWindowResize);
        }

        // --- 1.1 è¾‰å…‰åæœŸå¤„ç† ---
// a.html:167 è¡Œå·¦å³
        function setupPostProcessing() {
        Â  Â  Â  Â  Â  Â  // ä½¿ç”¨æ¨¡å—é¡¶éƒ¨çš„ import å˜é‡
        Â  Â  Â  Â  Â  Â  composer = new EffectComposer(renderer); // <--- THREE.EffectComposer æ”¹ä¸º EffectComposer
        Â  Â  Â  Â  Â  Â  
        Â  Â  Â  Â  Â  Â  // ä½¿ç”¨æ¨¡å—é¡¶éƒ¨çš„ import å˜é‡
        Â  Â  Â  Â  Â  Â  composer.addPass(new RenderPass(scene, camera)); // <--- THREE.RenderPass æ”¹ä¸º RenderPass

        Â  Â  Â  Â  Â  Â  // ä½¿ç”¨æ¨¡å—é¡¶éƒ¨çš„ import å˜é‡
        Â  Â  Â  Â  Â  Â  const bloomPass = new UnrealBloomPass( // <--- THREE.UnrealBloomPass æ”¹ä¸º UnrealBloomPass
        Â  Â  Â  Â  Â  Â  Â  Â  new THREE.Vector2(window.innerWidth, window.innerHeight),
        Â  Â  Â  Â  Â  Â  Â  Â  CONFIG.BLOOM_STRENGTH,
        Â  Â  Â  Â  Â  Â  Â  Â  CONFIG.BLOOM_RADIUS,
        Â  Â  Â  Â  Â  Â  Â  Â  CONFIG.BLOOM_THRESHOLD
        Â  Â  Â  Â  Â  Â  );
        Â  Â  Â  Â  Â  Â  composer.addPass(bloomPass);

        Â  Â  Â  Â  Â  Â  // å¯é€‰ï¼šæ·»åŠ æ›´å¤šé€šé“å¦‚ FXAA, Vignette ç­‰å¢åŠ ç”µå½±æ„Ÿ
        Â  Â  Â  Â  }

        // --- 2. åœ£è¯æ ‘è£…é¥°ç‰© (Instanced Mesh) ---
        function createChristmasParticles() {
            const tempObject = new THREE.Object3D();
            const positions = new Float32Array(CONFIG.PARTICLE_COUNT * 3);
            const scales = new Float32Array(CONFIG.PARTICLE_COUNT);

            // æ ¸å¿ƒæè´¨ï¼šé‡‘å±é‡‘ + å“‘å…‰ç»¿ + çº¢è‰²ï¼Œå¹¶èƒ½è‡ªå‘å…‰ (é…åˆè¾‰å…‰)
            const material = new THREE.MeshStandardMaterial({
                color: 0xFFD700, // é‡‘å±é‡‘
                emissive: 0xFFD700, // è‡ªå‘å…‰
                emissiveIntensity: 1.5,
                roughness: 0.1, // ä½ç²—ç³™åº¦æ¨¡æ‹Ÿé‡‘å±å…‰æ³½
                metalness: 0.9,
                transparent: true,
                opacity: 0.9,
            });

            // å‡ ä½•ä½“ç»„åˆï¼šçƒä½“ã€æ­£æ–¹ä½“ã€ç³–æœæ£
            const geometries = [
                new THREE.SphereGeometry(0.08, 8, 8),
                new THREE.BoxGeometry(0.15, 0.15, 0.15),
                new THREE.CylinderGeometry(0.05, 0.05, 0.3, 12) // ç®€åŒ–ç‰ˆç³–æœæ£
            ];
            const treeMesh = new THREE.Group();

            for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
                // éšæœºé€‰æ‹©ä¸€ä¸ªå‡ ä½•ä½“
                const geo = geometries[Math.floor(Math.random() * geometries.length)];
                
                // ä½¿ç”¨ InstancedMesh æå‡æ€§èƒ½
                const mesh = new THREE.InstancedMesh(geo, material, CONFIG.PARTICLE_COUNT);
                // ç¡®ä¿åªæœ‰ä¸€æ¬¡ InstancedMesh çš„è®¾ç½®
                if (i === 0) particleMesh = mesh;
                
                // åˆå§‹/åˆæ‹¢æ€ä½ç½® (åœ£è¯æ ‘åœ†é”¥ä½“)
                const y = Math.random() * CONFIG.TREE_HEIGHT; // yè½´é«˜åº¦
                const radius = (1 - y / CONFIG.TREE_HEIGHT) * 1.5 * Math.random(); // åº•éƒ¨å®½ï¼Œé¡¶éƒ¨çª„
                const angle = Math.random() * Math.PI * 2;
                
                // ç›®æ ‡ä½ç½® (åˆæ‹¢)
                const targetX = radius * Math.cos(angle);
                const targetZ = radius * Math.sin(angle);
                const targetY = y + (Math.random() - 0.5) * 0.5; // å¢åŠ å¾®å°æŠ–åŠ¨
                
                tempObject.position.set(targetX, targetY, targetZ);
                tempObject.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                const scale = 0.5 + Math.random() * 1.5;
                tempObject.scale.set(scale, scale, scale);
                
                tempObject.updateMatrix();
                
                // ä¿å­˜åˆå§‹åˆæ‹¢ä½ç½®
                particleMesh.setMatrixAt(i, tempObject.matrix);
                
                // ä¿å­˜ç²’å­æ•°æ®ï¼Œç”¨äºæ•£å¼€æ€å’ŒåŠ¨ç”»
                positions[i * 3 + 0] = targetX;
                positions[i * 3 + 1] = targetY;
                positions[i * 3 + 2] = targetZ;
                scales[i] = scale;
            }

            particleMesh.instanceMatrix.needsUpdate = true;
            particleMesh.userData = { positions, scales, geometryIndices: [] }; // å­˜å‚¨æ•°æ®

            scene.add(particleMesh);
        }

        // --- 2.1 ç…§ç‰‡äº‘å¤„ç† ---
        document.getElementById('photo-input').addEventListener('change', handlePhotoUpload);

        function handlePhotoUpload(event) {
            const files = Array.from(event.target.files).slice(0, CONFIG.PHOTO_COUNT_MAX);
            document.getElementById('photo-count').textContent = ` (${files.length} å¼ ç…§ç‰‡)`;
            
            // æ¸…ç†æ—§ç…§ç‰‡
            photoPlanes.forEach(p => scene.remove(p));
            photoPlanes = [];
            originalPhotoPositions = [];
            selectedPhoto = null;

            files.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const texture = new THREE.TextureLoader().load(e.target.result);
                    // ç…§ç‰‡æè´¨ï¼šä½¿ç”¨ Basic æè´¨é…åˆè¾‰å…‰ï¼Œæˆ– Standard æè´¨å¢åŠ æ·±åº¦
                    const material = new THREE.MeshBasicMaterial({ 
                        map: texture, 
                        side: THREE.DoubleSide,
                        transparent: true, 
                        opacity: 1.0, 
                        // æ·»åŠ ä¸€ä¸ªå°çš„å‘å…‰åŒºåŸŸï¼Œæ¨¡æ‹Ÿç…§ç‰‡å…‰æ™•
                        color: 0xFFFFFF 
                    });
                    
                    const geometry = new THREE.PlaneGeometry(1.5, 1); // é»˜è®¤ 3:2 æ¯”ä¾‹
                    const photoMesh = new THREE.Mesh(geometry, material);
                    
                    // åˆå§‹ä½ç½®ï¼šåˆæ‹¢åˆ°åœ£è¯æ ‘å†…éƒ¨çš„ä¸€ä¸ªéšæœºç‚¹
                    const pos = new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        (Math.random() * CONFIG.TREE_HEIGHT * 0.8) + 0.5,
                        (Math.random() - 0.5) * 2
                    );
                    photoMesh.position.copy(pos);
                    photoMesh.lookAt(camera.position); // åˆå§‹æœå‘ç›¸æœº
                    
                    photoMesh.userData = {
                        index: index,
                        targetPosition: pos.clone(), // åŠ¨æ€ç›®æ ‡ä½ç½®
                        targetRotation: photoMesh.rotation.clone(),
                        originalScale: 1.0,
                        // æ•£å¼€æ€ä½ç½®ï¼šçƒå½¢éšæœºåˆ†å¸ƒ
                        scatterPosition: new THREE.Vector3(
                            (Math.random() - 0.5) * 15,
                            (Math.random() - 0.5) * 15 + CONFIG.TREE_HEIGHT / 2,
                            (Math.random() - 0.5) * 15
                        )
                    };

                    photoPlanes.push(photoMesh);
                    scene.add(photoMesh);
                };
                reader.readAsDataURL(file);
            });
            // é‡æ–°è¿›å…¥åˆæ‹¢æ€ï¼Œç¡®ä¿ç…§ç‰‡åˆ°ä½
            setTimeout(() => setState(STATE.CLOSED), 100);
        }

        // --- 3. çŠ¶æ€ç®¡ç†ä¸å¹³æ»‘è¿‡æ¸¡ (TWEEN.js) ---
        function setState(newState) {
            if (currentState === newState) return;
            document.getElementById('current-state').textContent = newState;
            
            const duration = CONFIG.STATE_TRANSITION_DURATION;
            const cameraTween = new TWEEN.Tween(camera.position)
                .easing(TWEEN.Easing.Quadratic.InOut);

            const objectTween = new TWEEN.Tween({ t: 0 })
                .to({ t: 1 }, duration)
                .easing(TWEEN.Easing.Quadratic.InOut)
                .onUpdate(({ t }) => {
                    updateObjectPositions(t);
                })
                .start();

            currentState = newState;
            selectedPhoto = null; // åˆ‡æ¢çŠ¶æ€æ—¶å–æ¶ˆé€‰ä¸­

            switch (newState) {
                case STATE.CLOSED:
                    // ç›¸æœºå›åˆ°åˆå§‹ä½ç½®
                    cameraTween.to(CONFIG.INITIAL_CAMERA_POS).start();
                    break;

                case STATE.SCATTERED:
                    // ç›¸æœºåé€€å¹¶æŠ¬é«˜ï¼Œæä¾›æ›´å¹¿é˜”çš„è§†è§’
                    const scatterCameraPos = new THREE.Vector3(0, CONFIG.TREE_HEIGHT * 1.5, 15);
                    cameraTween.to(scatterCameraPos).start();
                    break;

                case STATE.PHOTO_ENLARGED:
                    // è¯¥çŠ¶æ€ç”±æ‰‹åŠ¿ "æŠ“" è§¦å‘ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†
                    // TWEEN ä»…ç”¨äºè¿‡æ¸¡ï¼Œç›®æ ‡ä½ç½®åœ¨ handDetection é€»è¾‘ä¸­ç¡®å®š
                    break;
            }

            // æ›´æ–°æ‰€æœ‰ç…§ç‰‡çš„ç›®æ ‡ä½ç½®
            photoPlanes.forEach(photo => {
                const target = photo.userData.targetPosition;
                const targetRot = photo.userData.targetRotation;
                const newScale = 1.0;
                
                switch (newState) {
                    case STATE.CLOSED:
                        // åˆæ‹¢ï¼šå›åˆ°æ ‘å†…éƒ¨çš„åˆå§‹ä½ç½®
                        target.copy(photo.userData.pos);
                        targetRot.set(0, 0, 0); 
                        break;
                    case STATE.SCATTERED:
                        // æ•£å¼€ï¼šç§»åŠ¨åˆ°éšæœºæ•£å¼€ä½ç½®ï¼Œéšæœºæ—‹è½¬
                        target.copy(photo.userData.scatterPosition);
                        targetRot.set(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2);
                        break;
                    // PHOTO_ENLARGED çŠ¶æ€çš„ targetPosition ç”± handDetection æ›´æ–°
                }

                // åˆ›å»ºç…§ç‰‡ä½ç½®å’Œæ—‹è½¬çš„è¿‡æ¸¡
                new TWEEN.Tween(photo.position)
                    .to(target, duration).easing(TWEEN.Easing.Quadratic.InOut).start();
                new TWEEN.Tween(photo.rotation)
                    .to(targetRot, duration).easing(TWEEN.Easing.Quadratic.InOut).start();
                new TWEEN.Tween(photo.scale)
                    .to(new THREE.Vector3(newScale, newScale, newScale), duration).easing(TWEEN.Easing.Quadratic.InOut).start();
            });
        }

        // åŠ¨ç”»å¸§æ›´æ–°æ‰€æœ‰è£…é¥°ç‰©çš„ä½ç½®
        function updateObjectPositions(t) {
            const tempObject = new THREE.Object3D();
            const { positions, scales } = particleMesh.userData;

            for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
                const startX = particleMesh.instanceMatrix.elements[i * 16 + 12];
                const startY = particleMesh.instanceMatrix.elements[i * 16 + 13];
                const startZ = particleMesh.instanceMatrix.elements[i * 16 + 14];

                let targetX, targetY, targetZ;
                let targetScale = scales[i];

                if (currentState === STATE.CLOSED) {
                    // ç›®æ ‡ä½ç½®æ˜¯å­˜å‚¨çš„åˆæ‹¢ä½ç½®
                    targetX = positions[i * 3 + 0];
                    targetY = positions[i * 3 + 1];
                    targetZ = positions[i * 3 + 2];
                } else {
                    // ç›®æ ‡ä½ç½®ï¼šæ•£å¼€æ€ (å¤§ç©ºé—´éšæœºåˆ†å¸ƒ)
                    // åŠ¨ç”»ä» CLOSED çŠ¶æ€å¼€å§‹ï¼Œç›®æ ‡æ˜¯ SCATTERED çŠ¶æ€
                    const scatterX = (Math.random() - 0.5) * 20;
                    const scatterY = (Math.random() - 0.5) * 20 + CONFIG.TREE_HEIGHT / 2;
                    const scatterZ = (Math.random() - 0.5) * 20;

                    targetX = THREE.MathUtils.lerp(positions[i * 3 + 0], scatterX, t);
                    targetY = THREE.MathUtils.lerp(positions[i * 3 + 1], scatterY, t);
                    targetZ = THREE.MathUtils.lerp(positions[i * 3 + 2], scatterZ, t);
                    targetScale = THREE.MathUtils.lerp(scales[i], 1.0 + Math.random(), t);
                }

                tempObject.position.set(targetX, targetY, targetZ);
                tempObject.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                tempObject.scale.set(targetScale, targetScale, targetScale);
                
                tempObject.updateMatrix();
                particleMesh.setMatrixAt(i, tempObject.matrix);
            }

            particleMesh.instanceMatrix.needsUpdate = true;
        }


        // --- 4. MediaPipe Hands é›†æˆ ---
        let hands;
        let lastHandPosition = null; // ç”¨äºè®¡ç®—æ‰‹éƒ¨ç§»åŠ¨é€Ÿåº¦

        async function setupMediaPipe() {
        Â  Â  Â  Â  Â  Â  // ä½¿ç”¨ä¸ <script> æ ‡ç­¾å¼•å…¥æ—¶ç›¸åŒçš„ç‰ˆæœ¬å· 0.8
        Â  Â  Â  Â  Â  Â  hands = new Hands({
        Â  Â  Â  Â  Â  Â  Â  Â  locateFile: (file) => {
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.8/${file}`;
        Â  Â  Â  Â  Â  Â  Â  Â  }
        Â  Â  Â  Â  Â  Â  });
        // ...

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);

            // å¯åŠ¨æ‘„åƒå¤´
            const videoElement = document.getElementById('camera-feed');
            const cameraFeed = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({ image: videoElement });
                },
                width: 640,
                height: 480
            });
            cameraFeed.start();
        }

        // 4.1 æ‰‹åŠ¿è¯†åˆ«æ ¸å¿ƒé€»è¾‘
        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const normalizedHandPosition = landmarks[9]; // ä¸­æŒ‡æ ¹éƒ¨ (ç”¨äºç›¸æœºæ§åˆ¶)
                
                // **æ‰‹åŠ¿è¯†åˆ«**
                const gesture = recognizeGesture(landmarks);
                
                // æ ¹æ®æ‰‹åŠ¿æ›´æ–°çŠ¶æ€
                handleGesture(gesture, normalizedHandPosition);
                
                // ç›¸æœºæ§åˆ¶ (æ‰‹éƒ¨æ—‹è½¬/ç§»åŠ¨)
                updateCameraControl(normalizedHandPosition);
            } else {
                lastHandPosition = null; // æ‰‹éƒ¨ä¸¢å¤±æ—¶é‡ç½®
            }
        }

        // 4.2 ç®€æ˜“æ‰‹åŠ¿è¯†åˆ«
        function recognizeGesture(landmarks) {
            const tipIndices = [4, 8, 12, 16, 20]; // æ‹‡æŒ‡ã€é£ŸæŒ‡ã€ä¸­æŒ‡ã€æ— åæŒ‡ã€å°æŒ‡æŒ‡å°–
            const mcpIndices = [2, 5, 9, 13, 17]; // æ‹‡æŒ‡æ ¹éƒ¨ï¼Œå…¶ä»–æŒ‡æ ¹éƒ¨
            
            let fingerUpCount = 0;
            // æ£€æŸ¥éæ‹‡æŒ‡å››æŒ‡æ˜¯å¦å¼ å¼€
            for (let i = 1; i < 5; i++) {
                // æŒ‡å°– Y åæ ‡æ˜¯å¦é«˜äºå¯¹åº”æŒ‡å…³èŠ‚ Y åæ ‡ (åœ¨ MediaPipe æ ‡å‡†åŒ–åæ ‡ç³»ä¸­ Y å‘ä¸Šä¸ºå°)
                if (landmarks[tipIndices[i]].y < landmarks[mcpIndices[i]].y) {
                    fingerUpCount++;
                }
            }
            
            const thumbOpen = landmarks[tipIndices[0]].x < landmarks[mcpIndices[0]].x; // ç®€åŒ–ï¼šæ‹‡æŒ‡åœ¨å·¦ä¾§ (å‡è®¾å³æ‰‹)

            // 1. **æ¡æ‹³ (Fist):** æ‰€æœ‰æŒ‡å°–éƒ½æ”¶æ‹¢ (Y å€¼å¤§äºæŒ‡æ ¹)
            if (fingerUpCount <= 1) { 
                return 'FIST';
            } 
            
            // 2. **å¼ å¼€äº”æŒ‡ (Open Hand):** æ‰€æœ‰æŒ‡å°–éƒ½å¼ å¼€
            if (fingerUpCount >= 4 && thumbOpen) {
                return 'OPEN_HAND';
            }
            
            // 3. **æŠ“å– (Grab):** æ‹‡æŒ‡å’Œé£ŸæŒ‡é è¿‘ (ç±»ä¼¼æåˆæˆ–æŠ“å–åŠ¨ä½œ)
            // ç®€åŒ–ï¼šé£ŸæŒ‡å’Œæ‹‡æŒ‡æŒ‡å°–è·ç¦»å¾ˆè¿‘
            const dist = landmarks[4].z - landmarks[8].z; // ä½¿ç”¨ Z è½´è·ç¦»åˆ¤æ–­æ·±åº¦æ¥è¿‘
            if (fingerUpCount >= 2 && dist < -0.1) { // é˜ˆå€¼æ ¹æ®æµ‹è¯•è°ƒæ•´
                return 'GRAB';
            }

            return 'NONE';
        }

        // 4.3 å¤„ç†æ‰‹åŠ¿åŠ¨ä½œ
        function handleGesture(gesture, normalizedHandPosition) {
            const isTransitioning = TWEEN.getAll().length > 0;
            if (isTransitioning) return; // åŠ¨ç”»è¿‡æ¸¡ä¸­ï¼Œå¿½ç•¥æ–°æ‰‹åŠ¿

            if (gesture === 'FIST' && currentState !== STATE.CLOSED) {
                setState(STATE.CLOSED);
            } else if (gesture === 'OPEN_HAND' && currentState !== STATE.SCATTERED) {
                setState(STATE.SCATTERED);
            } else if (gesture === 'GRAB' && currentState === STATE.SCATTERED) {
                // ä»…åœ¨æ•£å¼€æ€ä¸‹å…è®¸æŠ“å–ç…§ç‰‡
                if (!selectedPhoto) {
                    // é¦–æ¬¡æŠ“å–ï¼šé€‰æ‹©ç…§ç‰‡
                    selectPhoto(normalizedHandPosition);
                } else {
                    // å·²é€‰ä¸­ç…§ç‰‡ï¼šä¿æŒé€‰ä¸­å¹¶è¿›å…¥ PHOTO_ENLARGED çŠ¶æ€
                    if (currentState !== STATE.PHOTO_ENLARGED) {
                         setState(STATE.PHOTO_ENLARGED);
                    }
                    
                    // ç…§ç‰‡æ”¾å¤§æ€ï¼šè¢«æŠ“å–çš„ç…§ç‰‡è·Ÿéšæ‰‹éƒ¨ç§»åŠ¨
                    updateEnlargedPhotoPosition(normalizedHandPosition);
                }
            } else if (gesture === 'NONE' && currentState === STATE.PHOTO_ENLARGED) {
                // æ¾å¼€æ‰‹å›åˆ°æ•£å¼€æ€
                setState(STATE.SCATTERED);
            }
        }

        // 4.4 é€‰ä¸­ç…§ç‰‡
        function selectPhoto(normalizedHandPosition) {
            // å°† MediaPipe çš„ 2D åæ ‡è½¬æ¢ä¸º Three.js çš„ Raycaster åæ ‡
            mouse.x = (normalizedHandPosition.x * 2) - 1;
            mouse.y = -(normalizedHandPosition.y * 2) + 1;

            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(photoPlanes);

            if (intersects.length > 0) {
                selectedPhoto = intersects[0].object;
                setState(STATE.PHOTO_ENLARGED);
            }
        }

        // 4.5 æ›´æ–°æ”¾å¤§ç…§ç‰‡çš„ä½ç½® (è·Ÿéšæ‰‹éƒ¨)
        function updateEnlargedPhotoPosition(normalizedHandPosition) {
            if (!selectedPhoto) return;

            // å°†æ‰‹éƒ¨ 2D åæ ‡æ˜ å°„åˆ°ç›¸æœºå‰æ–¹çš„ 3D å¹³é¢ä¸Š
            const distance = 4; // ç…§ç‰‡æ”¾ç½®åœ¨ç›¸æœºå‰ 4 ä¸ªå•ä½
            const vector = new THREE.Vector3(
                normalizedHandPosition.x * 2 - 1, 
                -(normalizedHandPosition.y * 2) + 1, 
                0.5
            );
            
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const newPos = camera.position.clone().add(dir.multiplyScalar(distance));
            
            // å¹³æ»‘è¿‡æ¸¡åˆ°æ–°ä½ç½®
            new TWEEN.Tween(selectedPhoto.position)
                .to(newPos, 50).start(); // å¿«é€Ÿè·Ÿéš
            
            // æ”¾å¤§
            const targetScale = 3.5; 
            new TWEEN.Tween(selectedPhoto.scale)
                .to(new THREE.Vector3(targetScale, targetScale, targetScale), 300).start();
            
            // å§‹ç»ˆé¢å‘ç›¸æœº
            selectedPhoto.lookAt(camera.position); 
        }

        // 4.6 ç›¸æœºæ—‹è½¬æ§åˆ¶
        function updateCameraControl(normalizedHandPosition) {
            if (currentState !== STATE.SCATTERED && currentState !== STATE.CLOSED) return;

            if (lastHandPosition) {
                const dx = (normalizedHandPosition.x - lastHandPosition.x) * CONFIG.HAND_SENSITIVITY * 100;
                const dy = (normalizedHandPosition.y - lastHandPosition.y) * CONFIG.HAND_SENSITIVITY * 100;
                
                // æ—‹è½¬ç›¸æœºï¼šé€šè¿‡è°ƒæ•´ç›¸æœºç»•ç›®æ ‡ç‚¹çš„è½¨é“
                const targetDistance = camera.position.distanceTo(cameraTarget);
                
                // å°†ç›¸æœºä½ç½®è½¬æ¢ä¸ºçƒåæ ‡
                const spherical = new THREE.Spherical().setFromVector3(camera.position.clone().sub(cameraTarget));

                // æ›´æ–°çƒåæ ‡çš„è§’åº¦
                spherical.theta += dx * Math.PI * 2; // æ°´å¹³æ—‹è½¬
                spherical.phi -= dy * Math.PI; // å‚ç›´æ—‹è½¬ (é™åˆ¶åœ¨ 0.1 åˆ° Math.PI - 0.1)
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                
                // è½¬æ¢å›ç¬›å¡å°”åæ ‡
                const newCameraPos = new THREE.Vector3().setFromSpherical(spherical).add(cameraTarget);
                
                // å¹³æ»‘è¿‡æ¸¡åˆ°æ–°ä½ç½®
                new TWEEN.Tween(camera.position)
                    .to(newCameraPos, 50).start(); // å¿«é€Ÿè·Ÿéšæ‰‹éƒ¨æ—‹è½¬
                
                camera.lookAt(cameraTarget);
            }

            lastHandPosition = normalizedHandPosition;
        }

        // --- 5. æ¸²æŸ“å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            // TWEEN æ›´æ–°
            TWEEN.update();

            // æ¸²æŸ“åœºæ™¯ (ä½¿ç”¨ EffectComposer)
            composer.render(delta);
        }

        // --- 6. è¾…åŠ©å‡½æ•° ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- å¯åŠ¨åº”ç”¨ ---
        initScene();
        setupMediaPipe();
        animate();
    </script>
</body>
</html>