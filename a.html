<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js æ‰‹åŠ¿æ§åˆ¶åœ£è¯æ ‘ (æ­£å¼ä¿®å¤ç‰ˆ)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0A141A;
            color: #EAECEF;
            font-family: 'Segoe UI', Tahoma, sans-serif;
        }

        /* é¢„è§ˆçª—å£ï¼šå·¦ä¸‹è§’æ˜¾ç¤ºæ‘„åƒå¤´å’Œéª¨æ¶ */
        #preview-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 240px;
            height: 180px;
            border: 2px solid #FFD700;
            border-radius: 12px;
            overflow: hidden;
            z-index: 200;
            background: #000;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        #camera-feed {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* é•œåƒ */
        }

        #output-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            pointer-events: none;
        }

        #info-box {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            z-index: 100;
            border-left: 5px solid #FF4500;
            max-width: 300px;
        }

        #info-box h3 { margin: 0 0 10px 0; color: #FFD700; }
        #info-box ul { padding-left: 20px; font-size: 0.9em; margin: 10px 0; }

        #photo-upload-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #FFD700;
        }

        button {
            background-color: #008000;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover { background-color: #006400; }
    </style>
</head>
<body>

    <div id="info-box">
        <h3>âœ¨ 3D åœ£è¯æ ‘æ‰‹åŠ¿æ§åˆ¶</h3>
        <p>çŠ¶æ€: <span id="current-state">åˆå§‹åŒ–ä¸­...</span></p>
        <ul>
            <li>âœŠ <b>æ¡æ‹³:</b> åœ£è¯æ ‘åˆæ‹¢æ€</li>
            <li>ğŸ–ï¸ <b>å¼ å¼€:</b> ç…§ç‰‡äº‘æ•£å¼€/æ—‹è½¬</li>
            <li>ğŸ‘Œ <b>æåˆ (Grab):</b> é€‰ä¸­å¹¶æ‹‰è¿‘ç…§ç‰‡</li>
        </ul>
    </div>

    <div id="preview-container">
        <video id="camera-feed" playsinline autoplay muted></video>
        <canvas id="output-canvas"></canvas>
    </div>

    <div id="photo-upload-container">
        <input type="file" id="photo-input" accept="image/*" multiple style="display: none;">
        <button onclick="document.getElementById('photo-input').click()">ä¸Šä¼ ç…§ç‰‡äº‘</button>
        <span id="photo-count"> (0 å¼ )</span>
    </div>

    <script src="https://unpkg.com/@tweenjs/tween.js@18.6.4/dist/tween.umd.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/examples/jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
        import * as VisionTasks from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js';

        // --- é…ç½® ---
        const CONFIG = {
            PARTICLE_COUNT: 4000,
            PHOTO_COUNT_MAX: 50,
            BLOOM: { strength: 1.5, radius: 0.4, threshold: 0 },
            TREE_HEIGHT: 6,
            INITIAL_CAMERA_POS: new THREE.Vector3(0, 3, 10)
        };

        const STATE = { CLOSED: 'CLOSED', SCATTERED: 'SCATTERED', PHOTO_ENLARGED: 'PHOTO_ENLARGED' };

        // --- å˜é‡ ---
        let scene, camera, renderer, composer, clock = new THREE.Clock();
// ä¿®æ”¹è¿™ä¸€è¡Œ
        let particleGroups = [], photoPlanes = [];
        let currentState = STATE.CLOSED;
        let selectedPhoto = null;
        let lastHandPosition = null;
        let handLandmarker;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        
        const videoElement = document.getElementById('camera-feed');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const statusEl = document.getElementById('current-state');

        // --- åˆå§‹åŒ–åœºæ™¯ ---
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050a0f);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(CONFIG.INITIAL_CAMERA_POS);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.body.appendChild(renderer.domElement);

            // åæœŸå¤„ç† (è¾‰å…‰)
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), CONFIG.BLOOM.strength, CONFIG.BLOOM.radius, CONFIG.BLOOM.threshold);
            composer.addPass(bloom);

            // ç¯å…‰
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const pointLight = new THREE.PointLight(0xffffff, 10);
            pointLight.position.set(5, 5, 5);
            scene.add(pointLight);

            createTree();
            window.addEventListener('resize', onWindowResize);
        }

                // --- åˆ›å»ºç²’å­åœ£è¯æ ‘ ---
        function createTree() {
            particleGroups = []; // æ¸…ç©ºæ•°ç»„
            const geometries = [
                new THREE.SphereGeometry(0.08, 8, 8),
                new THREE.BoxGeometry(0.12, 0.12, 0.12),
                new THREE.CylinderGeometry(0.02, 0.02, 0.3, 8)
            ];

            const colors = [0xFFD700, 0xFF0000, 0x2E8B57, 0xFFFFFF];
            const countPerColor = Math.floor(CONFIG.PARTICLE_COUNT / colors.length);
            const dummy = new THREE.Object3D();

            colors.forEach((hexColor) => {
                const randomGeo = geometries[Math.floor(Math.random() * geometries.length)];
                const mat = new THREE.MeshStandardMaterial({ 
                    color: hexColor, 
                    emissive: hexColor, 
                    emissiveIntensity: 0.4,
                    metalness: 0.7,
                    roughness: 0.2
                });

                const mesh = new THREE.InstancedMesh(randomGeo, mat, countPerColor);
                const originalPositions = []; // æ¯ä¸ªç»„è®°å½•è‡ªå·±çš„ä½ç½®

                for (let i = 0; i < countPerColor; i++) {
                    const y = Math.random() * CONFIG.TREE_HEIGHT;
                    const r = (1 - y / CONFIG.TREE_HEIGHT) * 2 * Math.random();
                    const angle = Math.random() * Math.PI * 2;
                    
                    const x = Math.cos(angle) * r;
                    const z = Math.sin(angle) * r;
                    
                    dummy.position.set(x, y, z);
                    dummy.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                    
                    // ä¿å­˜ä½ç½®
                    originalPositions.push(x, y, z);
                }
                
                mesh.instanceMatrix.needsUpdate = true;
                mesh.userData.originalPositions = originalPositions; // å­˜å…¥è¯¥ mesh çš„æ•°æ®ä¸­
                scene.add(mesh);
                particleGroups.push(mesh); // åŠ å…¥ç®¡ç†æ•°ç»„
            });
        }
                // --- æ ¸å¿ƒé€»è¾‘ï¼šè®¾ç½®çŠ¶æ€ ---
        function setState(newState) {
            if (currentState === newState) return;
            currentState = newState;
            statusEl.textContent = newState;

            if (newState === STATE.CLOSED) {
                new TWEEN.Tween(camera.position).to(CONFIG.INITIAL_CAMERA_POS, 1500).easing(TWEEN.Easing.Quadratic.InOut).start();
                animateParticles(0);
                photoPlanes.forEach(p => animatePhoto(p, p.userData.originPos, new THREE.Euler(0,0,0), 1));
            } else if (newState === STATE.SCATTERED) {
                animateParticles(1);
                photoPlanes.forEach(p => animatePhoto(p, p.userData.scatterPos, p.userData.scatterRot, 1));
            }
        }

        function animateParticles(t) {
            const dummy = new THREE.Object3D();
            
            new TWEEN.Tween({ val: 0 }).to({ val: 1 }, 1500)
            .easing(TWEEN.Easing.Cubic.Out)
            .onUpdate((obj) => {
                particleGroups.forEach(mesh => {
                    const pos = mesh.userData.originalPositions;
                    for (let i = 0; i < mesh.count; i++) {
                        const idx = i * 3;
                        const factor = t === 1 ? obj.val : (1 - obj.val);
                        
                        // è¿™é‡Œçš„ 5 å’Œ 2 æ˜¯æ•£å¼€çš„å¹…åº¦ï¼Œä½ å¯ä»¥æ ¹æ®å–œå¥½è°ƒæ•´
                        dummy.position.set(
                            pos[idx] * (1 + factor * 5),
                            pos[idx+1] * (1 + factor * 2),
                            pos[idx+2] * (1 + factor * 5)
                        );
                        
                        // æ•£å¼€æ—¶ç¨å¾®å¢åŠ ä¸€ç‚¹éšæœºæ—‹è½¬ï¼Œçœ‹èµ·æ¥æ›´è‡ªç„¶
                        dummy.rotation.set(pos[idx] * factor, pos[idx+1] * factor, 0);
                        dummy.updateMatrix();
                        mesh.setMatrixAt(i, dummy.matrix);
                    }
                    mesh.instanceMatrix.needsUpdate = true;
                });
            }).start();
        }
        function animatePhoto(mesh, pos, rot, scale) {
            new TWEEN.Tween(mesh.position).to(pos, 1000).easing(TWEEN.Easing.Back.Out).start();
            new TWEEN.Tween(mesh.rotation).to(rot, 1000).start();
            new TWEEN.Tween(mesh.scale).to({x: scale, y: scale, z: scale}, 500).start();
        }

        // --- MediaPipe ä¸ æ‘„åƒå¤´ ---
        async function initAI() {
            try {
                const vision = await VisionTasks.FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                handLandmarker = await VisionTasks.HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });

                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
                videoElement.srcObject = stream;
                videoElement.onloadedmetadata = () => {
                    videoElement.play();
                    statusEl.textContent = "å‡†å¤‡å°±ç»ª";
                    detectHands();
                };
            } catch (e) {
                statusEl.textContent = "é”™è¯¯: " + e.message;
            }
        }

        function detectHands() {
            if (videoElement.currentTime !== lastVideoTime) {
                var lastVideoTime = videoElement.currentTime;
                const results = handLandmarker.detectForVideo(videoElement, performance.now());
                processResults(results);
            }
            requestAnimationFrame(detectHands);
        }

        function processResults(results) {
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            if (results.landmarks && results.landmarks.length > 0) {
                const hand = results.landmarks[0];
                drawSkeleton(hand);
                
                // è¯†åˆ«
                const gesture = getGesture(hand);
                const pos = hand[9]; // ä¸­æŒ‡æ ¹éƒ¨

                if (gesture === 'FIST') setState(STATE.CLOSED);
                else if (gesture === 'OPEN') setState(STATE.SCATTERED);
                else if (gesture === 'GRAB') handleGrab(pos);

                updateCamera(pos);
            }
        }

        function getGesture(hand) {
            const fingersUp = [8, 12, 16, 20].filter(i => hand[i].y < hand[i-2].y).length;
            const pinchDist = Math.hypot(hand[4].x - hand[8].x, hand[4].y - hand[8].y);
            if (fingersUp <= 1) return 'FIST';
            if (pinchDist < 0.04) return 'GRAB';
            if (fingersUp >= 3) return 'OPEN';
            return 'NONE';
        }

        function handleGrab(pos) {
            if (currentState !== STATE.SCATTERED) return;
            mouse.x = (pos.x * 2) - 1;
            mouse.y = -(pos.y * 2) + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(photoPlanes);
            if (intersects.length > 0) {
                selectedPhoto = intersects[0].object;
                const targetPos = new THREE.Vector3().copy(camera.position).add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(4));
                animatePhoto(selectedPhoto, targetPos, camera.rotation, 3);
            }
        }

        function updateCamera(pos) {
            if (!lastHandPosition) { lastHandPosition = pos; return; }
            const dx = pos.x - lastHandPosition.x;
            const dy = pos.y - lastHandPosition.y;
            camera.position.x += dx * 15;
            camera.position.y -= dy * 15;
            camera.lookAt(0, 3, 0);
            lastHandPosition = pos;
        }

        function drawSkeleton(landmarks) {
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
            canvasCtx.fillStyle = "#FFD700";
            landmarks.forEach(p => canvasCtx.fillRect(p.x * canvasElement.width, p.y * canvasElement.height, 6, 6));
        }

        // --- ç…§ç‰‡ä¸Šä¼  ---
        document.getElementById('photo-input').addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            document.getElementById('photo-count').textContent = ` (${files.length} å¼ )`;
            
            files.forEach(file => {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const texture = new THREE.TextureLoader().load(ev.target.result);
                    const mesh = new THREE.Mesh(
                        new THREE.PlaneGeometry(1.2, 0.9),
                        new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide })
                    );
                    const origin = new THREE.Vector3((Math.random()-0.5)*1, Math.random()*5, (Math.random()-0.5)*1);
                    mesh.position.copy(origin);
                    mesh.userData = {
                        originPos: origin,
                        scatterPos: new THREE.Vector3((Math.random()-0.5)*12, Math.random()*8, (Math.random()-0.5)*10),
                        scatterRot: new THREE.Euler(Math.random(), Math.random(), 0)
                    };
                    photoPlanes.push(mesh);
                    scene.add(mesh);
                };
                reader.readAsDataURL(file);
            });
        });

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            composer.render();
        }

        // å¯åŠ¨
        initScene();
        initAI();
        animate();
    </script>
</body>
</html>