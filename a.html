<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Three.js ç’€ç’¨åœ£è¯æ ‘ - äº¤äº’ä¿®å¤ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050810; color: #fff; font-family: 'Segoe UI', sans-serif; }
        #preview-container { position: absolute; bottom: 20px; left: 20px; width: 220px; height: 165px; border: 2px solid #FFD700; border-radius: 12px; overflow: hidden; z-index: 200; box-shadow: 0 0 20px rgba(255,215,0,0.3); }
        #camera-feed { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        #output-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); pointer-events: none; }
        #ui-layer { position: absolute; top: 20px; left: 20px; padding: 20px; background: rgba(0, 10, 30, 0.8); border-radius: 12px; z-index: 100; border-left: 6px solid #FFD700; backdrop-filter: blur(5px); }
        #photo-upload-container { position: absolute; bottom: 20px; right: 20px; z-index: 100; background: rgba(0, 0, 0, 0.6); padding: 15px; border-radius: 8px; }
        button { background: linear-gradient(135deg, #00b300, #008000); color: white; border: none; padding: 12px 24px; border-radius: 30px; cursor: pointer; font-weight: bold; box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
        .hint { font-size: 0.85em; color: #aaa; margin-top: 10px; }
        b { color: #FFD700; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h2 style="margin:0; color:#FFD700;">âœ¨ äº¤äº’å¼é‡‘å±åœ£è¯æ ‘</h2>
        <p>çŠ¶æ€: <span id="current-state" style="font-weight:bold; color:#00FF00;">ç­‰å¾…è¯†åˆ«...</span></p>
        <div class="hint">
            âœŠ <b>æåˆ/æ¡æ‹³:</b> æ±‡èšæˆæ ‘ï¼ˆç…§ç‰‡åŒæ­¥æ”¶ç¼©ï¼‰<br>
            ğŸ–ï¸ <b>å¼ å¼€æ‰‹æŒ:</b> ç²’å­æ•£å¼€ï¼ˆç…§ç‰‡ç¯ç»•ï¼‰<br>
            ğŸ‘Œ <b>æä½æ‰‹æŒ‡:</b> æŠ“å–æœ€è¿‘çš„ç…§ç‰‡å¹¶æ”¾å¤§
        </div>
    </div>

    <div id="preview-container">
        <video id="camera-feed" playsinline autoplay muted></video>
        <canvas id="output-canvas"></canvas>
    </div>

    <div id="photo-upload-container">
        <input type="file" id="photo-input" accept="image/*" multiple style="display: none;">
        <button onclick="document.getElementById('photo-input').click()">ä¸Šä¼ ç…§ç‰‡è®°å¿†</button>
        <span id="photo-count"> (å·²è½½å…¥ 0 å¼ )</span>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/examples/jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "@tweenjs/tween.js": "https://unpkg.com/@tweenjs/tween.js@23.1.3/dist/tween.esm.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as TWEEN from '@tweenjs/tween.js'; 
        import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
        import * as VisionTasks from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js';

        const CONFIG = {
            PARTICLE_COUNT: 2500,
            TREE_HEIGHT: 8,
            BLOOM_STRENGTH: 1.0,
            INITIAL_CAMERA_POS: new THREE.Vector3(0, 4, 15)
        };

        const STATE = { TREE: 'TREE', SCATTER: 'SCATTER' };
        let currentState = STATE.TREE;
        let scene, camera, renderer, composer;
        let particleGroups = [], photoPlanes = [];
        let handLandmarker, videoElement, canvasCtx;
        let focusedPhoto = null;

        async function init() {
            initScene();
            initLights();
            setupPhotoUpload();
            await initAI();
            animate();
        }

        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020408);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(CONFIG.INITIAL_CAMERA_POS);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.body.appendChild(renderer.domElement);

            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), CONFIG.BLOOM_STRENGTH, 0.4, 0.1);
            composer.addPass(bloomPass);

            createTreeParticles();
            window.addEventListener('resize', onWindowResize);
        }

        function initLights() {
            scene.add(new THREE.AmbientLight(0xffffff, 0.3));
            const p1 = new THREE.PointLight(0xffd700, 30, 30); p1.position.set(5, 10, 5); scene.add(p1);
            const p2 = new THREE.PointLight(0xff0000, 20, 30); p2.position.set(-5, 2, 5); scene.add(p2);
            const p3 = new THREE.PointLight(0x00ccff, 20, 30); p3.position.set(0, 8, -5); scene.add(p3);
        }

        function createTreeParticles() {
            const geometries = [new THREE.SphereGeometry(0.1, 12, 12), new THREE.BoxGeometry(0.12, 0.12, 0.12)];
            const colors = [0xFFD700, 0xFF3333, 0x228B22, 0xEEEEEE];
            const dummy = new THREE.Object3D();

            colors.forEach((col) => {
                const mat = new THREE.MeshStandardMaterial({ 
                    color: col, metalness: 0.9, roughness: 0.15, 
                    emissive: col, emissiveIntensity: 0.05 
                });
                const mesh = new THREE.InstancedMesh(geometries[Math.floor(Math.random()*2)], mat, 600);
                const posArr = [], scaleArr = [];

                for (let i = 0; i < 600; i++) {
                    const y = Math.random() * CONFIG.TREE_HEIGHT;
                    const r = (1 - y / CONFIG.TREE_HEIGHT) * 3 * Math.random();
                    const angle = Math.random() * Math.PI * 2;
                    const x = Math.cos(angle) * r;
                    const z = Math.sin(angle) * r;
                    const s = 0.5 + Math.random();
                    dummy.position.set(x, y, z);
                    dummy.scale.set(s, s, s);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                    posArr.push(x, y, z); scaleArr.push(s);
                }
                mesh.userData = { posArr, scaleArr };
                scene.add(mesh);
                particleGroups.push(mesh);
            });
        }

        function setupPhotoUpload() {
            const input = document.getElementById('photo-input');
            const loader = new THREE.TextureLoader();
            input.addEventListener('change', (e) => {
                const files = Array.from(e.target.files);
                document.getElementById('photo-count').textContent = ` (å·²è½½å…¥ ${files.length} å¼ )`;
                files.forEach((file, idx) => {
                    const url = URL.createObjectURL(file);
                    loader.load(url, (tex) => {
                        const aspect = tex.image.width / tex.image.height;
                        const mat = new THREE.MeshStandardMaterial({ map: tex, side: THREE.DoubleSide, roughness: 0.8 });
                        const plane = new THREE.Mesh(new THREE.PlaneGeometry(1.8 * aspect, 1.8), mat);
                        const angle = (idx / files.length) * Math.PI * 2;
                        plane.position.set(Math.cos(angle)*6, 2 + Math.random()*4, Math.sin(angle)*6);
                        plane.lookAt(0, 4, 0);
                        scene.add(plane);
                        photoPlanes.push(plane);
                    });
                });
            });
        }

        // --- æ ¸å¿ƒåŠ¨ç”»é€»è¾‘ï¼šåŒæ­¥åœ£è¯æ ‘ä¸ç…§ç‰‡ ---
        function transitionTo(newState) {
            if (currentState === newState) return;
            currentState = newState;
            document.getElementById('current-state').textContent = newState === STATE.TREE ? "ğŸ„ åœ£è¯æ ‘æ”¶ç¼©" : "âœ¨ ç²’å­æ•£å¼€";

            const targetVal = newState === STATE.SCATTER ? 1 : 0;
            const dummy = new THREE.Object3D();

            new TWEEN.Tween({ val: 1 - targetVal })
                .to({ val: targetVal }, 1200)
                .easing(TWEEN.Easing.Quadratic.InOut)
                .onUpdate((obj) => {
                    // 1. ç²’å­åŠ¨ç”»
                    particleGroups.forEach(mesh => {
                        const { posArr, scaleArr } = mesh.userData;
                        for (let i = 0; i < mesh.count; i++) {
                            const idx = i * 3;
                            dummy.position.set(
                                posArr[idx] * (1 + obj.val * 5),
                                posArr[idx+1] * (1 + obj.val * 2),
                                posArr[idx+2] * (1 + obj.val * 5)
                            );
                            dummy.scale.setScalar(scaleArr[i]);
                            dummy.updateMatrix();
                            mesh.setMatrixAt(i, dummy.matrix);
                        }
                        mesh.instanceMatrix.needsUpdate = true;
                    });

                    // 2. ç…§ç‰‡åŒæ­¥ç¼©æ”¾ä¸ä½ç§»
                    photoPlanes.forEach((plane, i) => {
                        if (plane === focusedPhoto) return; // æ­£åœ¨æŠ“å–çš„ç…§ç‰‡ä¸å‚ä¸æ­¤åŠ¨ç”»
                        const angle = (i / photoPlanes.length) * Math.PI * 2;
                        const r = 2.5 + (obj.val * 4); // æ ‘æ€åŠå¾„2.5ï¼Œæ•£å¼€åŠå¾„6.5
                        plane.position.x = Math.cos(angle) * r;
                        plane.position.z = Math.sin(angle) * r;
                        
                        // ç¼©å°é€»è¾‘ï¼šæ ‘æ€æ—¶ 0.4å€ï¼Œæ•£å¼€æ—¶ 1.0å€
                        const s = 0.4 + (obj.val * 0.6);
                        plane.scale.set(s, s, s);
                        plane.lookAt(0, 4, 0);
                    });
                }).start();
        }

        async function initAI() {
            videoElement = document.getElementById('camera-feed');
            const canvasElement = document.getElementById('output-canvas');
            canvasCtx = canvasElement.getContext('2d');
            const vision = await VisionTasks.FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await VisionTasks.HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });
            const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
            videoElement.srcObject = stream;
            videoElement.onloadedmetadata = () => { videoElement.play(); runDetection(); };
        }

        function runDetection() {
            if (videoElement.currentTime !== runDetection.lastTime) {
                runDetection.lastTime = videoElement.currentTime;
                const result = handLandmarker.detectForVideo(videoElement, performance.now());
                canvasCtx.clearRect(0, 0, 640, 480);
                if (result.landmarks && result.landmarks[0]) {
                    const hand = result.landmarks[0];
                    drawHand(hand);
                    const thumbTip = hand[4], indexTip = hand[8];
                    const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                    const fingersUp = [12, 16, 20].filter(i => hand[i].y < hand[i-2].y).length;

                    if (pinchDist < 0.05) {
                        handleGrabGesture();
                    } else if (fingersUp >= 2) {
                        transitionTo(STATE.SCATTER);
                        releasePhoto();
                    } else {
                        transitionTo(STATE.TREE);
                        releasePhoto();
                    }
                }
            }
            requestAnimationFrame(runDetection);
        }

        // --- æ ¸å¿ƒä¿®å¤ï¼šæŠ“å–å¹¶å¼ºåˆ¶é¢æœç”¨æˆ· ---
        function handleGrabGesture() {
            if (photoPlanes.length === 0 || focusedPhoto) return;

            let closestPhoto = null;
            let minDistance = Infinity;
            photoPlanes.forEach(p => {
                const dist = p.position.distanceTo(camera.position);
                if (dist < minDistance) { minDistance = dist; closestPhoto = p; }
            });

            if (closestPhoto) {
                focusedPhoto = closestPhoto;
                document.getElementById('current-state').textContent = "âœŠ æŠ“ä½å›å¿†ä¸­...";

                new TWEEN.Tween(focusedPhoto.position)
                    .to({ x: 0, y: 4, z: 10 }, 800)
                    .easing(TWEEN.Easing.Back.Out)
                    .onUpdate(() => {
                        // ã€å®‰å…¨ä¿®å¤ã€‘å¢åŠ  null æ£€æŸ¥ï¼Œé˜²æ­¢åŠ¨ç”»æ®‹ç•™å¯¼è‡´å´©æºƒ
                        if (focusedPhoto) focusedPhoto.lookAt(camera.position);
                    })
                    .start();

                new TWEEN.Tween(focusedPhoto.scale)
                    .to({ x: 1.2, y: 1.2, z: 1.2 }, 800)
                    .easing(TWEEN.Easing.Back.Out)
                    .start();
            }
        }

        function releasePhoto() {
            if (focusedPhoto) {
                const photoToRelease = focusedPhoto; // ä½¿ç”¨ä¸´æ—¶å˜é‡é˜²æ­¢ TWEEN å†²çª
                focusedPhoto = null; // ç«‹å³ç½®ç©ºï¼Œé¿å… handleGrabGesture é‡å¤è¿›å…¥

                const idx = photoPlanes.indexOf(photoToRelease);
                const angle = (idx / photoPlanes.length) * Math.PI * 2;
                const r = currentState === STATE.TREE ? 2.5 : 6;
                
                new TWEEN.Tween(photoToRelease.position)
                    .to({ x: Math.cos(angle)*r, y: 3 + Math.random()*2, z: Math.sin(angle)*r }, 600)
                    .start();
                
                new TWEEN.Tween(photoToRelease.scale)
                    .to({ x: currentState === STATE.TREE ? 0.4 : 1, y: currentState === STATE.TREE ? 0.4 : 1, z: 1 }, 600)
                    .onUpdate(() => {
                        photoToRelease.lookAt(0, 4, 0);
                    })
                    .start();
            }
        }

        function drawHand(landmarks) {
            canvasCtx.fillStyle = "#FFD700";
            landmarks.forEach(p => canvasCtx.fillRect(p.x * 640, p.y * 480, 5, 5));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            particleGroups.forEach(m => m.rotation.y += 0.002);
            if(currentState === STATE.SCATTER && !focusedPhoto) {
                photoPlanes.forEach((p, i) => {
                    p.position.y += Math.sin(Date.now()*0.001 + i)*0.005;
                });
            }
            composer.render();
        }

        init();
    </script>
</body>
</html>