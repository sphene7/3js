<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js é‡‘å±åœ£è¯æ ‘ (ESM ä¿®å¤ç‰ˆ)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020508; color: #EAECEF; font-family: sans-serif; }
        #preview-container { position: absolute; bottom: 20px; left: 20px; width: 240px; height: 180px; border: 2px solid #FFD700; border-radius: 12px; overflow: hidden; z-index: 200; background: #000; }
        #camera-feed { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        #output-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); pointer-events: none; }
        #info-box { position: absolute; top: 20px; left: 20px; padding: 15px; background: rgba(0, 0, 0, 0.7); border-radius: 8px; z-index: 100; border-left: 5px solid #FF4500; }
        #photo-upload-container { position: absolute; bottom: 20px; right: 20px; z-index: 100; background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 8px; border: 1px solid #FFD700; }
        button { background-color: #008000; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; }
    </style>
</head>
<body>

    <div id="info-box">
        <h3>âœ¨ é‡‘å±è´¨æ„Ÿåœ£è¯æ ‘</h3>
        <p>çŠ¶æ€: <span id="current-state">ç­‰å¾…æ‘„åƒå¤´...</span></p>
        <ul style="font-size: 0.8em;">
            <li>âœŠ <b>æ¡æ‹³:</b> åœ£è¯æ ‘å½¢æ€</li>
            <li>ğŸ–ï¸ <b>å¼ å¼€:</b> ç²’å­æ•£å°„</li>
        </ul>
    </div>

    <div id="preview-container">
        <video id="camera-feed" playsinline autoplay muted></video>
        <canvas id="output-canvas"></canvas>
    </div>

    <div id="photo-upload-container">
        <input type="file" id="photo-input" accept="image/*" multiple style="display: none;">
        <button onclick="document.getElementById('photo-input').click()">ä¸Šä¼ ç…§ç‰‡äº‘</button>
        <span id="photo-count"> (0 å¼ )</span>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/examples/jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "@tweenjs/tween.js": "https://unpkg.com/@tweenjs/tween.js@23.1.3/dist/tween.esm.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        // 2. è¿™é‡Œçš„ TWEEN å¼•å…¥æ–¹å¼å˜äº†ï¼Œä¸å†ä¾èµ–å…¨å±€å˜é‡
        import * as TWEEN from '@tweenjs/tween.js'; 
        import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
        import * as VisionTasks from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js';

        const CONFIG = {
            PARTICLE_COUNT: 3000,
            TREE_HEIGHT: 7,
            INITIAL_CAMERA_POS: new THREE.Vector3(0, 3, 12)
        };

        const STATE = { CLOSED: 'CLOSED', SCATTERED: 'SCATTERED' };

        let scene, camera, renderer, composer;
        let particleGroups = []; 
        let photoPlanes = [];
        let currentState = STATE.CLOSED;
        let handLandmarker;
        let lastHandPosition = null;
        
        const videoElement = document.getElementById('camera-feed');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const statusEl = document.getElementById('current-state');

        async function init() {
            initScene();
            await initAI();
            animate();
        }

        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x010305);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(CONFIG.INITIAL_CAMERA_POS);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping; 
            document.body.appendChild(renderer.domElement);

            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.0, 0.4, 0.1);
            composer.addPass(bloom);

            // ç¯å…‰
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const colors = [0xffffff, 0xffd700, 0xff4444];
            [[5, 5, 5], [-5, 2, 5], [0, 8, -5]].forEach((p, i) => {
                const light = new THREE.PointLight(colors[i], 15, 30);
                light.position.set(...p);
                scene.add(light);
            });

            createTree();
            window.addEventListener('resize', onWindowResize);
        }

        function createTree() {
            particleGroups.forEach(g => scene.remove(g));
            particleGroups = [];

            const geometries = [
                new THREE.SphereGeometry(0.1, 16, 16),
                new THREE.BoxGeometry(0.12, 0.12, 0.12),
                new THREE.ConeGeometry(0.08, 0.2, 8)
            ];

            const colors = [0xFFD700, 0xFF3333, 0x00CCFF, 0xEAECEF]; 
            const countPerColor = Math.floor(CONFIG.PARTICLE_COUNT / colors.length);
            const dummy = new THREE.Object3D();

            colors.forEach((hexColor) => {
                const mat = new THREE.MeshStandardMaterial({ 
                    color: hexColor, 
                    metalness: 0.95, 
                    roughness: 0.1,
                    emissive: hexColor,
                    emissiveIntensity: 0.05
                });

                const mesh = new THREE.InstancedMesh(geometries[Math.floor(Math.random()*3)], mat, countPerColor);
                const posData = [];
                const scaleData = [];

                for (let i = 0; i < countPerColor; i++) {
                    const y = Math.random() * CONFIG.TREE_HEIGHT;
                    const r = (1 - y / CONFIG.TREE_HEIGHT) * 2.5 * Math.random();
                    const angle = Math.random() * Math.PI * 2;
                    const x = Math.cos(angle) * r;
                    const z = Math.sin(angle) * r;
                    const s = 0.4 + Math.random() * 1.2;

                    dummy.position.set(x, y, z);
                    dummy.scale.set(s, s, s);
                    dummy.rotation.set(Math.random(), Math.random(), 0);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                    
                    posData.push(x, y, z);
                    scaleData.push(s);
                }
                
                mesh.userData = { posData, scaleData };
                scene.add(mesh);
                particleGroups.push(mesh);
            });
        }

        function setState(newState) {
            if (currentState === newState) return;
            currentState = newState;
            statusEl.textContent = newState === STATE.CLOSED ? "ğŸ„ åœ£è¯æ ‘æ¨¡å¼" : "âœ¨ ç²’å­æ•£å¼€";
            
            const target = newState === STATE.SCATTERED ? 1 : 0;
            const dummy = new THREE.Object3D();

            new TWEEN.Tween({ val: 1 - target })
                .to({ val: target }, 1500)
                .easing(TWEEN.Easing.Exponential.Out)
                .onUpdate((obj) => {
                    particleGroups.forEach(mesh => {
                        const { posData, scaleData } = mesh.userData;
                        for (let i = 0; i < mesh.count; i++) {
                            const idx = i * 3;
                            const factor = obj.val;
                            dummy.position.set(
                                posData[idx] * (1 + factor * 5),
                                posData[idx+1] * (1 + factor * 2),
                                posData[idx+2] * (1 + factor * 5)
                            );
                            const s = scaleData[i];
                            dummy.scale.set(s, s, s);
                            dummy.rotation.set(posData[idx] * factor, posData[idx+1] * factor, 0);
                            dummy.updateMatrix();
                            mesh.setMatrixAt(i, dummy.matrix);
                        }
                        mesh.instanceMatrix.needsUpdate = true;
                    });
                }).start();
        }

        async function initAI() {
            try {
                const vision = await VisionTasks.FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                handLandmarker = await VisionTasks.HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 1
                });
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
                videoElement.srcObject = stream;
                videoElement.onloadedmetadata = () => { videoElement.play(); detectHands(); };
            } catch (e) { statusEl.textContent = "ç›¸æœºæƒé™è¢«æ‹’ç»"; }
        }

        function detectHands() {
            if (videoElement.currentTime !== detectHands.lastTime) {
                detectHands.lastTime = videoElement.currentTime;
                const results = handLandmarker.detectForVideo(videoElement, performance.now());
                if (results.landmarks && results.landmarks[0]) {
                    const hand = results.landmarks[0];
                    drawSkeleton(hand);
                    const fingersUp = [8, 12, 16, 20].filter(i => hand[i].y < hand[i-2].y).length;
                    
                    if (fingersUp <= 1) setState(STATE.CLOSED);
                    else if (fingersUp >= 4) setState(STATE.SCATTERED);
                    
                    const pos = hand[9];
                    if (lastHandPosition) {
                        camera.position.x += (pos.x - lastHandPosition.x) * 12;
                        camera.position.y -= (pos.y - lastHandPosition.y) * 12;
                        camera.lookAt(0, 3, 0);
                    }
                    lastHandPosition = pos;
                }
            }
            requestAnimationFrame(detectHands);
        }

        function drawSkeleton(landmarks) {
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.fillStyle = "#FFD700";
            landmarks.forEach(p => canvasCtx.fillRect(p.x * canvasElement.width, p.y * canvasElement.height, 4, 4));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update(); // è¿™é‡Œçš„ TWEEN å·²ç»é€šè¿‡ import æ­£å¸¸å¼•å…¥äº†
            composer.render();
        }

        init();
    </script>
</body>
</html>